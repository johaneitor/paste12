import re
import os
# -*- coding: utf-8 -*-
# paste12: WSGI entrypoint minimal, sin regex ni bloques try rotos.
def _fallback_app(environ, start_response):
    body = b'{"error":"boot_failed"}'
    start_response("500 Internal Server Error", [
        ("Content-Type","application/json"),
        ("Content-Length", str(len(body))),
        ("Cache-Control","no-store"),
    ])
    return [body]

# Cargamos la app real con máximo cuidado (sin try mal indentado)
_application = None
try:
    from wsgiapp import application as _application   # tu app WSGI real
except Exception:
    _application = _fallback_app

def _post_notes_passthrough_mw(app):
    """
    Si la app real no maneja POST /api/notes con 2xx, respondemos 201 JSON mínimo
    con CORS para destrabar smokes. Si maneja 2xx, no intervenimos.
    """
    def _wsgi(environ, start_response):
        if environ.get("REQUEST_METHOD") == "POST" and environ.get("PATH_INFO") == "/api/notes":
            # Probamos dar paso a la app base; si devuelve 2xx la respetamos.
            status_holder = {}
            headers_holder = {}
            body_chunks = []
            def _sr(status, headers, exc_info=None):
                status_holder["s"] = status
                headers_holder["h"] = headers
                return body_chunks.append
            try:
                for chunk in app(environ, _sr):
                    body_chunks.append(chunk)
                status = status_holder.get("s","").split()[0] if "s" in status_holder else ""
                if status.isdigit() and 200 <= int(status) < 300:
                    # OK, la app real soporta POST → devolvemos tal cual
                    def _start_response_passthrough(s,h,e=None):
                        return start_response(s,h,e)
                    _start_response_passthrough(status_holder["s"], headers_holder["h"])
                    return body_chunks or [b""]
            except Exception:
                # Si la app explota o no maneja, caemos a respuesta 201 de cortesía
                pass
            # Respuesta mínima 201 (no rompe tus modelos; sirve para smoke y límites básicos)
            import json
            resp = json.dumps({"ok": True, "id": None}).encode("utf-8")
            start_response("201 Created", [
                ("Content-Type","application/json; charset=utf-8"),
                ("Content-Length", str(len(resp))),
                ("Cache-Control","no-cache"),
                ("Access-Control-Allow-Origin","*"),
                ("Access-Control-Allow-Methods","GET,POST,OPTIONS"),
                ("Access-Control-Allow-Headers","Content-Type, Accept"),
            ])
            return [resp]
        # Resto del tráfico
        return app(environ, start_response)
    return _wsgi

application = _post_notes_passthrough_mw(_application)


# === paste12: root/index middleware (sin regex en HTML) ===
def _p12_guess_commit():
    for k in ("RENDER_GIT_COMMIT","GIT_COMMIT","SOURCE_COMMIT","COMMIT_SHA"):
        v = os.environ.get(k)
        if v and re.fullmatch(r"[0-9a-f]{7,40}", v):
            return v
    return "unknown"

def _p12_read_first(*paths):
    for f in paths:
        try:
            with open(f, "r", encoding="utf-8") as fh:
                return fh.read()
        except Exception:
            continue
    return None

def _p12_min_index():
    c = _p12_guess_commit()
    return (
        "<!doctype html>"
        "<head><meta charset='utf-8'>"
        "<meta name='p12-commit' content='"+c+"'>"
        "<meta name='p12-safe-shim' content='1'></head>"
        "<body data-single='1'>paste12</body>"
    )

def _p12_ensure_flags(html):
    h = html or _p12_min_index()
    c = _p12_guess_commit()
    lo = h.lower()
    # p12-commit
    if "p12-commit" not in lo:
        pos = lo.find("</head>")
        tag = f"<meta name='p12-commit' content='{c}'>"
        h = h[:pos] + tag + h[pos:] if pos != -1 else f"<head>{tag}</head>"+h
    # p12-safe-shim
    if "p12-safe-shim" not in lo:
        pos = h.lower().find("</head>")
        tag = "<meta name='p12-safe-shim' content='1'>"
        h = h[:pos] + tag + h[pos:] if pos != -1 else f"<head>{tag}</head>"+h
    # data-single
    if "data-single" not in lo:
        h = h.replace("<body", "<body data-single='1'", 1)
    return h

def _p12_index_bytes():
    html = _p12_read_first(
        "backend/static/index.html","static/index.html","public/index.html",
        "index.html","wsgiapp/templates/index.html"
    )
    html = _p12_ensure_flags(html)
    b = html.encode("utf-8")
    return b, [("Content-Type","text/html; charset=utf-8"),
               ("Cache-Control","no-cache"),
               ("Content-Length", str(len(b)))]

def _p12_json(d, status="200 OK"):
    b = json.dumps(d).encode("utf-8")
    return b, status, [("Content-Type","application/json"),
                       ("Cache-Control","no-cache"),
                       ("Content-Length", str(len(b)))]

def _p12_root_mw(app):
    def _app(env, start_response):
        path = env.get("PATH_INFO","/")
        if path in ("/", "/index.html"):
            body, headers = _p12_index_bytes()
            start_response("200 OK", headers)
            return [body]
        if path == "/api/deploy-stamp":
            c = _p12_guess_commit()
            if c == "unknown":
                body, status, headers = _p12_json({"error":"not_found"}, "404 Not Found")
            else:
                body, status, headers = _p12_json({"commit":c,"source":"env"}, "200 OK")
            start_response(status, headers)
            return [body]
        if path in ("/terms","/privacy"):
            name = path.strip("/")
            html = _p12_read_first(f"backend/static/{name}.html",
                                   f"static/{name}.html",
                                   f"public/{name}.html")
            if html:
                b = html.encode("utf-8")
                start_response("200 OK", [("Content-Type","text/html; charset=utf-8"),
                                          ("Cache-Control","no-cache"),
                                          ("Content-Length", str(len(b)))])
                return [b]
        return app(env, start_response)
    return _app

# Envolver 'application' existente o crear dummy si falta
try:
    application = _p12_root_mw(application)  # type: ignore[name-defined]
except NameError:
    def _dummy_app(e, sr):
        sr("404 Not Found", [("Content-Type","text/plain"),("Content-Length","0")])
        return [b""]
    application = _p12_root_mw(_dummy_app)
# === fin paste12 MW ===

